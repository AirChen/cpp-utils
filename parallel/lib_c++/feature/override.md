
重写（override）、重载（overload）和隐藏（overwrite）在C++中是3个完全不同的概念，但是在平时的工作交流中，我发现有很多C++程序员对它们的概念模糊不清，经常误用或者混用这3个概念，所以在说明override说明符之前，我们先梳理一下三者的区别。

  1．重写（override）的意思更接近覆盖，在C++中是指派生类覆盖了基类的虚函数，这里的覆盖必须满足有相同的函数签名和返回类型，也就是说有相同的函数名、形参列表以及返回类型。

  2．重载（overload），它通常是指在同一个类中有两个或者两个以上函数，它们的函数名相同，但是函数签名不同，也就是说有不同的形参。这种情况在类的构造函数中最容易看到，为了让类更方便使用，我们经常会重载多个构造函数。

  3．隐藏（overwrite）的概念也十分容易与上面的概念混淆。隐藏是是指基类成员函数，无论它是否为虚函数，当派生类出现同名函数时，如果派生类函数签名不同于基类函数，则基类函数会被隐藏。如果派生类函数签名与基类函数相同，则需要确定基类函数是否为虚函数，如果是虚函数，则这里的概念就是重写；否则基类函数也会被隐藏。另外，如果还想使用基类函数，可以使用using关键字将其引入派生类。

意外隐藏：
class Base {
public:
    virtual void foo(int) {}
    void bar() {}
};

class Derived : public Base {
public:
    void foo(double) {}   // 隐藏 Base::foo(int)，非重写！
    void bar() {}         // 隐藏 Base::bar()
};

Derived d;
d.foo(1);    // 编译错误：Base::foo(int) 被隐藏，需改为 d.Base::foo(1)

修改：
class Derived : public Base {
public:
    void foo(int) override {}  // 明确重写
    using Base::bar;           // 引入基类 bar()
    void bar() {}              // 现在基类 bar() 和子类 bar() 共存
};

编译器
所以C++11标准提供了一个非常实用的override说明符，这个说明符必须放到虚函数的尾部，它明确告诉编译器这个虚函数需要覆盖基类的虚函数，一旦编译器发现该虚函数不符合重写规则，就会给出错误提示。
C++11标准引入final说明符解决了上述问题，它告诉编译器该虚函数不能被派生类重写。